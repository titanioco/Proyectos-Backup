<!DOCTYPE html><html><head><meta charset="UTF-8"><title>Binary Search Tree (BST) - Module Documentation</title><style>* { margin: 0; padding: 0; box-sizing: border-box; }body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; line-height: 1.6; color: #333; background: #f5f5f5; }.container { max-width: 1200px; margin: 0 auto; padding: 20px; }.header { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 60px 40px; text-align: center; margin-bottom: 40px; border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,0.2); }.header h1 { font-size: 3em; font-weight: 700; margin-bottom: 15px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }.header .subtitle { font-size: 1.3em; opacity: 0.95; font-weight: 300; }.header .date { margin-top: 15px; font-size: 0.95em; opacity: 0.85; }.section { background: white; margin: 30px 0; padding: 40px; border-radius: 8px; box-shadow: 0 2px 15px rgba(0,0,0,0.1); }.section h2 { color: #667eea; font-size: 2em; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 3px solid #667eea; }.section h3 { color: #764ba2; font-size: 1.5em; margin-top: 30px; margin-bottom: 15px; }.section h4 { color: #555; font-size: 1.2em; margin-top: 20px; margin-bottom: 10px; }.section p { margin: 15px 0; text-align: justify; }.section ul, .section ol { margin: 15px 0 15px 30px; }.section li { margin: 8px 0; }.info-box { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 25px; border-radius: 8px; margin: 25px 0; box-shadow: 0 5px 15px rgba(0,0,0,0.1); }.info-box h3 { color: white; margin-top: 0; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 10px; }.algorithm-box { background: #f8f9fa; border-left: 5px solid #667eea; padding: 25px; margin: 25px 0; border-radius: 5px; }.algorithm-box h3 { color: #667eea; margin-top: 0; }.code-block { background: #2d3748; color: #e2e8f0; padding: 25px; border-radius: 8px; overflow-x: auto; font-family: 'Courier New', Consolas, monospace; font-size: 14px; line-height: 1.5; margin: 20px 0; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }.code-block .comment { color: #68d391; }.code-block .keyword { color: #fc8181; font-weight: bold; }.code-block .type { color: #90cdf4; }.code-block .method { color: #fbd38d; }.code-block .string { color: #f6ad55; }.complexity-table { width: 100%; border-collapse: collapse; margin: 25px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }.complexity-table th { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 15px; text-align: left; font-weight: 600; }.complexity-table td { border: 1px solid #e2e8f0; padding: 12px 15px; }.complexity-table tr:nth-child(even) { background: #f7fafc; }.complexity-table tr:hover { background: #edf2f7; }.highlight { background: #fbd38d; padding: 3px 8px; border-radius: 4px; font-weight: 600; }.warning-box { background: #fff5f5; border-left: 5px solid #fc8181; padding: 20px; margin: 25px 0; border-radius: 5px; }.success-box { background: #f0fff4; border-left: 5px solid #68d391; padding: 20px; margin: 25px 0; border-radius: 5px; }.note-box { background: #ebf8ff; border-left: 5px solid #4299e1; padding: 20px; margin: 25px 0; border-radius: 5px; }.example-box { background: #fffff0; border: 2px dashed #f6ad55; padding: 25px; margin: 25px 0; border-radius: 8px; }.example-box h4 { color: #d69e2e; margin-top: 0; }.steps-list { counter-reset: step-counter; list-style: none; padding-left: 0; }.steps-list li { counter-increment: step-counter; margin: 20px 0; padding: 20px; background: #f7fafc; border-left: 4px solid #667eea; border-radius: 5px; position: relative; padding-left: 60px; }.steps-list li::before { content: counter(step-counter); position: absolute; left: 15px; top: 50%; transform: translateY(-50%); background: #667eea; color: white; width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; }.comparison-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 25px 0; }.comparison-item { background: #f7fafc; padding: 20px; border-radius: 8px; border: 2px solid #e2e8f0; }.comparison-item h4 { color: #667eea; margin-top: 0; }.footer { text-align: center; margin-top: 60px; padding: 30px; color: #718096; border-top: 2px solid #e2e8f0; background: white; border-radius: 8px; }.footer p { margin: 8px 0; }@media print { body { background: white; } .section { box-shadow: none; page-break-inside: avoid; } }</style></head><body><div class="container"><div class="header"><h1>üìä Binary Search Tree (BST)</h1><div class="subtitle">Complete Module Documentation</div><div class="date">Interactive Data Structures Learning Suite</div></div><div class="section"><h2>1. Introduction</h2><p>A <span class="highlight">Binary Search Tree (BST)</span> is a hierarchical data structure where each node has at most two children (left and right). It follows a specific ordering property that makes searching, insertion, and deletion operations efficient.</p><div class="info-box"><h3>Key Characteristics</h3><ul><li><strong>Ordered Structure:</strong> All values in the left subtree are less than the root, and all values in the right subtree are greater</li><li><strong>Recursive Property:</strong> Both left and right subtrees are themselves binary search trees</li><li><strong>No Duplicates:</strong> Traditional BST implementations don't allow duplicate values</li><li><strong>Dynamic Size:</strong> Can grow and shrink as needed</li></ul></div></div><div class="section"><h2>2. Implementation Details</h2><h3>2.1 Node Structure</h3><p>The fundamental building block of a BST is the node, which contains:</p><div class="code-block"><span class="keyword">public class</span> <span class="type">BSTNode</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Data fields</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">int</span> value;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// The value stored in the node</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">BSTNode</span> left;&nbsp;&nbsp;<span class="comment">// Reference to left child</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">BSTNode</span> right;&nbsp;<span class="comment">// Reference to right child</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">int</span> x, y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Coordinates for visualization</span><br>}</div><h3>2.2 Core Operations</h3><div class="algorithm-box"><h4>Insert Operation</h4><p>Insertion follows the BST property to find the correct position:</p><ol class="steps-list"><li>Start at the root node</li><li>If the value to insert is less than current node, go left; otherwise go right</li><li>Repeat until finding an empty position</li><li>Create a new node at that position</li></ol><div class="code-block"><span class="keyword">public</span> <span class="type">BSTNode</span> <span class="method">insert</span>(<span class="type">BSTNode</span> node, <span class="type">int</span> value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (node == <span class="keyword">null</span>) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return new</span> <span class="type">BSTNode</span>(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (value &lt; node.value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.left = <span class="method">insert</span>(node.left, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;} <span class="keyword">else if</span> (value &gt; node.value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right = <span class="method">insert</span>(node.right, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> node;<br>}</div></div><div class="algorithm-box"><h4>Search Operation</h4><p>Searching efficiently locates a value by following the BST property:</p><ol class="steps-list"><li>Start at the root node</li><li>Compare target value with current node</li><li>If equal, value is found</li><li>If less, search left subtree; if greater, search right subtree</li><li>If reach null, value doesn't exist</li></ol><div class="code-block"><span class="keyword">public</span> <span class="type">boolean</span> <span class="method">search</span>(<span class="type">BSTNode</span> node, <span class="type">int</span> value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return false</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (value == node.value) <span class="keyword">return true</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (value &lt; node.value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="method">search</span>(node.left, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> <span class="method">search</span>(node.right, value);<br>}</div></div><div class="algorithm-box"><h4>Delete Operation</h4><p>Deletion is the most complex operation with three cases:</p><ol class="steps-list"><li><strong>Leaf Node:</strong> Simply remove the node</li><li><strong>One Child:</strong> Replace node with its child</li><li><strong>Two Children:</strong> Find inorder successor (smallest in right subtree), replace value, delete successor</li></ol><div class="code-block"><span class="keyword">public</span> <span class="type">BSTNode</span> <span class="method">delete</span>(<span class="type">BSTNode</span> node, <span class="type">int</span> value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return null</span>;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (value &lt; node.value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.left = <span class="method">delete</span>(node.left, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;} <span class="keyword">else if</span> (value &gt; node.value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right = <span class="method">delete</span>(node.right, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;} <span class="keyword">else</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Node with one or no child</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (node.left == <span class="keyword">null</span>) <span class="keyword">return</span> node.right;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span> (node.right == <span class="keyword">null</span>) <span class="keyword">return</span> node.left;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Node with two children</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.value = <span class="method">findMin</span>(node.right);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.right = <span class="method">delete</span>(node.right, node.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span> node;<br>}</div></div></div><div class="section"><h2>3. Time and Space Complexity</h2><table class="complexity-table"><thead><tr><th>Operation</th><th>Best Case</th><th>Average Case</th><th>Worst Case</th><th>Space Complexity</th></tr></thead><tbody><tr><td><strong>Search</strong></td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>Insert</strong></td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>Delete</strong></td><td>O(log n)</td><td>O(log n)</td><td>O(n)</td><td>O(1)</td></tr><tr><td><strong>Inorder Traversal</strong></td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>O(h)</td></tr><tr><td><strong>Space (Tree)</strong></td><td>O(n)</td><td>O(n)</td><td>O(n)</td><td>-</td></tr></tbody></table><div class="note-box"><p><strong>Note:</strong> Best and average cases assume a balanced tree. Worst case O(n) occurs when the tree becomes skewed (degenerates into a linked list). The height h = log n for balanced trees and h = n for skewed trees.</p></div></div><div class="section"><h2>4. Visualization Features in This Module</h2><div class="comparison-grid"><div class="comparison-item"><h4>üé® Visual Elements</h4><ul><li>Node highlighting during operations</li><li>Color-coded states (normal, visiting, found)</li><li>Smooth animations between steps</li><li>Clear edge connections</li></ul></div><div class="comparison-item"><h4>‚öôÔ∏è Interactive Controls</h4><ul><li>Insert, delete, and search operations</li><li>Animation speed control</li><li>Step-by-step execution</li><li>Operation history tracking</li></ul></div><div class="comparison-item"><h4>üìä Analysis Tools</h4><ul><li>Real-time tree statistics</li><li>Step explanations</li><li>Multiple traversal modes</li><li>Export functionality</li></ul></div></div></div><div class="section"><h2>5. Real-World Applications</h2><div class="example-box"><h4>Common Use Cases:</h4><ul><li><strong>Database Indexing:</strong> BSTs are used in database systems for efficient data retrieval</li><li><strong>File Systems:</strong> Directory structures often use tree-based organization</li><li><strong>Expression Parsing:</strong> Compiler design uses BSTs for syntax trees</li><li><strong>Priority Queues:</strong> Can be implemented using BSTs</li><li><strong>Auto-complete:</strong> Dictionary implementations for word suggestions</li><li><strong>Router Tables:</strong> Network routing algorithms</li></ul></div></div><div class="section"><h2>6. Advantages and Limitations</h2><div class="comparison-grid"><div class="comparison-item" style="border-color: #68d391;"><h4 style="color: #38a169;">‚úÖ Advantages</h4><ul><li>Efficient searching compared to arrays</li><li>Dynamic size (grows/shrinks as needed)</li><li>Inorder traversal gives sorted data</li><li>Simple to understand and implement</li><li>Flexible for various applications</li></ul></div><div class="comparison-item" style="border-color: #fc8181;"><h4 style="color: #e53e3e;">‚ö†Ô∏è Limitations</h4><ul><li>Can degenerate to O(n) if not balanced</li><li>No random access like arrays</li><li>Extra memory for pointers</li><li>Performance depends on insertion order</li><li>Not cache-friendly for modern CPUs</li></ul></div></div><div class="note-box"><p><strong>Solution:</strong> Use self-balancing trees like AVL or Red-Black trees to guarantee O(log n) performance.</p></div></div><div class="section"><h2>7. Complete Code Example</h2><p>Here's how the BST module is implemented in our visualization tool:</p><div class="code-block"><span class="comment">// BSTAlgorithm.java - Core BST implementation</span><br><span class="keyword">public class</span> <span class="type">BSTAlgorithm</span> {<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">BSTNode</span> root;<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span> <span class="type">int</span> nodeCount = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Main operations with animation support</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> <span class="method">insert</span>(<span class="type">int</span> value) { ... }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public boolean</span> <span class="method">delete</span>(<span class="type">int</span> value) { ... }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public boolean</span> <span class="method">search</span>(<span class="type">int</span> value) { ... }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public void</span> <span class="method">clear</span>() { root = null; }<br><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Traversal methods</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span> <span class="type">List&lt;Integer&gt;</span> <span class="method">inorderTraversal</span>() { ... }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span> <span class="type">List&lt;Integer&gt;</span> <span class="method">preorderTraversal</span>() { ... }<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span> <span class="type">List&lt;Integer&gt;</span> <span class="method">postorderTraversal</span>() { ... }<br>}</div><p>The visualization panel (<code>BSTPanel.java</code>) handles rendering, while the control panel (<code>BSTControls.java</code>) manages user interactions and animation flow.</p></div><div class="section"><h2>8. Learning Tips & Best Practices</h2><div class="success-box"><h4>üìö Study Recommendations:</h4><ol><li><strong>Start Simple:</strong> Begin with insert and search operations before tackling deletion</li><li><strong>Visualize:</strong> Draw trees on paper while learning to understand structure</li><li><strong>Practice Traversals:</strong> Master inorder, preorder, and postorder traversals</li><li><strong>Understand Recursion:</strong> BST operations are naturally recursive</li><li><strong>Test Edge Cases:</strong> Empty tree, single node, skewed trees</li><li><strong>Compare with AVL:</strong> Understand why balanced trees are important</li></ol></div><div class="warning-box"><h4>‚ö†Ô∏è Common Pitfalls:</h4><ul><li>Forgetting to update parent references during deletion</li><li>Not handling null cases properly</li><li>Confusing left and right subtree rules</li><li>Ignoring tree balance (can lead to poor performance)</li><li>Memory leaks in languages without garbage collection</li></ul></div></div></div><div class="footer"><p><strong>Interactive Data Structures Learning Suite</strong></p><p>Generated on: December 09, 2025 at 16:04:08</p><p>¬© 2025 - Educational Resource for Computer Science Students</p><p style="margin-top: 15px; font-size: 0.9em; color: #a0aec0;">This documentation can be saved as PDF using your browser's Print to PDF function</p></div></body></html>